[[972KClosestPointsToOrigin-dr.excalidraw]]
[[Heap]]

-taking square root wasnt needed here



Given an array of `points` where `points[i] = [xi, yi]` represents a point on the **X-Y** plane and an integer `k`, return the `k` closest points to the origin `(0, 0)`.

The distance between two points on the **X-Y** plane is the Euclidean distance (i.e., `√(x1 - x2)2 + (y1 - y2)2`).

You may return the answer in **any order**. The answer is **guaranteed** to be **unique** (except for the order that it is in).


```python
import math
import heapq
class Solution:
    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
        def get_eucDist(points):
            ar=[]
            for point in points:
    
                x=point[0]
                y=point[1]
                res=math.sqrt((x)**2 + (y)**2)
                ar.append([point,res])

            return ar

		# get each element along with its distance
        heap=[(dist,arr) for arr ,dist in get_eucDist(points)]
        #minheap
        heapq.heapify(heap)
        res=[]
		# remove top k elements 
        for i in range(k):
            x=heapq.heappop(heap)
            print(x)
            res.append(x[1])

        return res

        

```

## Time Complexity
|            |                                                                                                                                                                                                                                                                                                                                   |
| ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| O(n log n) | The time complexity is O(n log n) because the code involves iterating through all the points to calculate the Euclidean distance, which takes O(n) time. Then, the heapify operation takes O(n log n) time. Finally, popping k elements from the heap takes O(k log n) time. Overall, the dominant time complexity is O(n log n). |

## Improvements
### 1. **Use `math.hypot(x, y)`** instead of `sqrt(x**2 + y**2)`

Cleaner, more readable:

python

CopyEdit

`res = math.hypot(x, y)`

## 2. Proper Naming of variables


### 3.**Use `heapq.nsmallest(k, heap)`** instead of popping `k` times

It's simpler and sometimes faster:


##  Optimal Code

### Little optimal :

```python
import math
import heapq

class Solution:

	def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
	
		heap=[(math.hypot(x,y),[x,y])for x ,y in points]		
		return [point for _, point in heapq.nsmallest(k,heap)]
```
O(n log k)
- heapq.nsmallest(n,arr)-> O(k*logk)
## More optimal:

klogn
```python
minHeap=[]
for x,y in points:
	dist=(x**2)+y**2
	minHeap.append([dist,x,y])
heapq.heapify(minHeap)
res=[]
while k>0:
dist,x,y=heapq.heappop(minHeap)
res.append([x,y])
k-=1
return res

```

