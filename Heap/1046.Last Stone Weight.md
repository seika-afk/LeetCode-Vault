[[Heap]]
[[1046-LastStoneWeight-dr.excalidraw]]

You are given an array of integers `stones` where `stones[i]` is the weight of the `ith` stone.

We are playing a game with the stones. On each turn, we choose the **heaviest two stones** and smash them together. Suppose the heaviest two stones have weights `x` and `y` with `x <= y`. The result of this smash is:

- If `x == y`, both stones are destroyed, and
- If `x != y`, the stone of weight `x` is destroyed, and the stone of weight `y` has new weight `y - x`.

At the end of the game, there is **at most one** stone left.

Return _the weight of the last remaining stone_. If there are no stones left, return `0`.

## Solution

```python
import heapq
class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:
        #basecase
        if len(stones) ==1:
            return stones[0]
        #creating Maxheap
        for i in range(len(stones)):
            stones[i]=-stones[i]
        heapq.heapify(stones)
        #removing till last element is left
        while len(stones)> 1:
            x=-heapq.heappop(stones)
           
            y=-heapq.heappop(stones)
            after_breaking=x-y
            if after_breaking !=0:
                heapq.heappush(stones,-after_breaking)
        if stones:
            return -stones[0]
        return 0
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        for i,n in enumerate(nums):
            nums[i]=n*n
        return sorted(nums)
```


## Time Complexity
The lastStoneWeight function uses a heap data structure which has a time complexity of ==O(log n)== for insertion and deletion operations. The while loop runs until there is only one element left in the heap, which can take up to n-1 iterations. Therefore, the overall time complexity is O(n log n). The sortedSquares function has a time complexity of O(n log n) as well because it uses the sorted function which has a time complexity of O(n log n) for sorting the list.

## Synopsis

- Used MaxHeap
- When Two stones are clashed -> remove 3 heaviest stone
- Do math between them
	- if left ,add
	- if not move oon
- lastly give the left element


## Improvements

---

### 1. **Use list comprehension for negation**

More Pythonic and concise:

python

CopyEdit

`stones = [-s for s in stones]`

---
### 2. **Rename variables for clarity**

Optional, but improves readability:

- `x` → `stone1`
    
- `y` → `stone2`
    
- `after_breaking` → `diff`